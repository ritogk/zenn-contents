---
title: "ã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’é…·ä½¿ã—ã¦ç†æƒ³ã®é“ã‚’æ¢ã™"
emoji: "ğŸ”ï¸"
type: "tech"
topics: ["Python", "gis", "OpenStreetMap", "GeoPandas", "OvertureMaps"]
published: true
published_at: 2024-12-25 00:01
---

# æ¦‚è¦

ã“ã®è¨˜äº‹ã§ã¯ã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ç†æƒ³ã®é“è·¯ã‚’æ¢ã™ãŸã‚ã®æ–¹æ³•ã«ã¤ã„ã¦è§£èª¬ã—ã¾ã™ã€‚
ã“ã®è¨˜äº‹ã®ã‚´ãƒ¼ãƒ«ã¯æŒ‡å®šã—ãŸç·¯åº¦çµŒåº¦ã®ç¯„å›²å†…ã‹ã‚‰ç†æƒ³ã®é“ã‚’æŠ½å‡ºã—ã¦ä¸Šä½10ä»¶ã‚’three.jsã«è¡¨ç¤ºã™ã‚‹ã¨ã“ã‚ã¾ã§ã¨ã—ã¾ã™ã€‚
ç†æƒ³ã®é“ã¯`ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã§èµ°ã‚‹ã‚ˆã†ãªå³ é“`ã¨ã—ã¾ã—ãŸã€‚
![ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã§èµ°ã‚‹ã‚ˆã†ãªå³ é“](/images/a1f4c292a469b8/image.png)_ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã§ã§ã¦ããã†ãªå³ é“_

å†…å®¹ã¯ç§ãŒå»å¹´ã®æ›¸ã„ãŸã“ã‚Œã‚’ãƒ–ãƒ©ã‚·ã‚¢ãƒƒãƒ—ã—ãŸã‚‚ã®ã«ãªã£ã¦ã„ã¾ã™ã€‚
https://zenn.dev/homing/articles/f9a314841c737d

# ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿

æ¢ç´¢ãƒ­ã‚¸ãƒƒã‚¯ã§ä½¿ç”¨ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã¯OpenStreetMapã®åœ°å›³ãƒ‡ãƒ¼ã‚¿ã‚’ä¸»è»¸ã¨ã—ã¦ã€ãã®ä¸Šã«åˆ¥ã®ãƒ‡ãƒ¼ã‚¿ã‚’é‡ã­åˆã‚ã›ã¦æƒ…å ±ã‚’å¢—ã‚„ã—ãŸç‰©ã‚’ä½¿ç”¨ã—ã¾ã™ã€‚
ã“ã¡ã‚‰ãŒä½¿ç”¨ã—ãŸãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚

- [OpenStreetMapã®é“è·¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯](https://www.openstreetmap.org/#map=16/35.38045/137.00005)
- [OpenStreetMapã®ã‚¿ã‚°(ãƒˆãƒ³ãƒãƒ«, æ©‹ç­‰)](https://www.openstreetmap.org/#map=16/35.38045/137.00005)
- [å›½åœŸåœ°ç†é™¢ã®æ¨™é«˜ãƒ¢ãƒ‡ãƒ«](https://fgd.gsi.go.jp/download/menu.php)
- [å›½åœŸåœ°ç†é™¢ã®è¡›æ˜Ÿå†™çœŸ](https://fgd.gsi.go.jp/download/menu.php)
- [OvertureMapsã®å»ºç‰©ãƒãƒªã‚´ãƒ³](https://overturemaps-org.translate.goog/?_x_tr_sl=en&_x_tr_tl=ja&_x_tr_hl=ja&_x_tr_pto=sc)
- [çœŒå˜ä½ã®ãƒãƒªã‚´ãƒ³](https://japonyol.net/editor/article/47-prefectures-geojson.html)

# æ¢ç´¢ã™ã‚‹é“è·¯ã®ç‰¹å¾´

ä»Šå›ã®å¯¾è±¡ã®é“ã¯`ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã§èµ°ã‚‹ã‚ˆã†ãªå³ é“`ã§ã™ã€‚
ã©ã®ã‚ˆã†ãªé“ã‹ã¨è¨€ã†ã¨å‘¨å›²ã‚’æ°—ã«ã›ãšã«é‹è»¢ãŒæ¥½ã—ã‚ã¦ãƒãƒ³ãƒ‰ãƒ«æ“ä½œãŒæ¿€ã—ã„é“ã§ã™ã€‚
[https://www.youtube.com/watch?v=buImljmfdcE](https://www.youtube.com/watch?v=buImljmfdcE)
ã“ã®ã‚ˆã†ãªé“è·¯ã®ç‰¹å¾´ã‚’å¤§ããåˆ†ã‘ã‚‹ã¨ã€Œèµ°ã‚Šã‚„ã™ã„é“ã€ã¨ã€Œä¸‰æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“ã€ã«ã‚ã‘ã‚‰ã‚Œã¾ã™ã€‚

## èµ°ã‚Šã‚„ã™ã„é“

èµ°ã‚Šã‚„ã™ã„é“ã¨ã¯å‘¨è¾ºã«æ„è­˜ã‚’å‘ã‘ã‚‹ã“ã¨ãªãè‡ªåˆ†ã®é‹è»¢ã«ã®ã¿é›†ä¸­ã§ãã‚‹é“ã®äº‹ã§ã™ã€‚
ã‚‚ã†å°‘ã—å…·ä½“çš„ã«ã™ã‚‹ã¨ã€é“å¹…ãŒåºƒãã€ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ãŒå¯¾å‘è»Šã‚„å‰å¾Œã®è»Šã‚’æ„è­˜ã™ã‚‹äº‹ãªãèµ°è¡Œã§ãã¦æ°‘å®¶ã‚„äº¤å·®ç‚¹ãŒå°‘ãªã„ã‚ˆã†ãªé“ã‚’æŒ‡ã—ã¾ã™ã€‚
è»Šå¹…ãŒç‹­ã‹ã£ãŸã‚Šã™ã‚‹é“ã¯å¸¸ã«å¯¾å‘è»Šã‚’æ„è­˜ã™ã‚‹å¿…è¦ãŒã‚ã£ãŸã‚Šã€æ°‘å®¶ã‚„äº¤å·®ç‚¹ãŒå¤šã‘ã‚Œã°æ­©è¡Œè€…ã‚„å‘¨å›²ã®è¦–ç·šã«æ„è­˜ãŒå‘ã„ã¦ã—ã¾ã†ã®ã§é‹è»¢ã«é›†ä¸­ã™ã‚‹äº‹ãŒã§ãã¾ã›ã‚“ã€‚
èµ°ã‚Šã‚„ã™ã„é“ã«ã¯ã“ã®ã‚ˆã†ãªç‰¹å¾´ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

- äº¤é€šé‡ãŒå°‘ãªã„
- äº¤å·®ç‚¹ãŒå°‘ãªã„
- å‘¨è¾ºã«æ°‘å®¶ãŒå°‘ãªã„
- é“å¹…ãŒã‚ã‚‹ç¨‹åº¦ç¢ºä¿ã•ã‚Œã¦ã„ã‚‹
  ![èµ°ã‚Šã‚„ã™ã„é“ã®ã‚¤ãƒ¡ãƒ¼ã‚¸](/images/a1f4c292a469b8/image1.png)
  _èµ°ã‚Šã‚„ã™ã„é“ã®ã‚¤ãƒ¡ãƒ¼ã‚¸_

## ä¸‰æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“

å³ é“ã¯x, y, zè»¸æ–¹å‘ã«è¤‡é›‘ãªå½¢çŠ¶ã‚’ã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªé“ã¯è»Šã®ç‰¹æ€§ãŒç¾ã‚Œã‚„ã™ã„ã§ã™ã€‚è»Šä½“ã®ãƒœãƒ‡ã‚£å‰›æ€§ã‚„ã‚¿ã‚¤ãƒ¤å‰›æ€§ãŒé«˜ã‘ã‚Œã°è»Šã¯ã‚¯ã‚¤ãƒƒã‚¯ã«æ›²ãŒã‚Šã¾ã™ã—ã€ãƒˆãƒ«ã‚¯ãŒã‚ã‚Œã°ã‚³ãƒ¼ãƒŠãƒ¼ã®ç«‹ã¡ä¸ŠãŒã‚Šã§åŠ é€Ÿæ„Ÿã‚’æ„Ÿã˜ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
![3æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“ã®ã‚¤ãƒ¡ãƒ¼ã‚¸](/images/a1f4c292a469b8/image2.png)
_3æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“ã®ã‚¤ãƒ¡ãƒ¼ã‚¸_
x, yè»¸ã®è¤‡é›‘æ€§ã¯OpenStreetMapã®å¹³é¢çš„ãªé“è·¯å½¢çŠ¶ã‹ã‚‰æ±‚ã‚ã‚‹äº‹ãŒã§ãã€zè»¸ã¯å›½åœŸåœ°ç†é™¢ã®æ¨™é«˜ãƒ¢ãƒ‡ãƒ«ã‹ã‚‰æ±‚ã‚ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
3æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“ã¯ã“ã®ã‚ˆã†ãªç‰¹å¾´ã‚’æŒã£ã¦ã„ã¾ã™ã€‚

- å‹¾é…ãŒã¤ã„ã¦ã„ã‚‹é“
- æ³¢æ‰“ã¤ã‚ˆã†ãªå‚ãŒå¤šã„é“
- è¤‡é›‘ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°æ“ä½œã‚’è¦æ±‚ã•ã‚Œã‚‹é“

# å‡¦ç†ã®æµã‚Œ

ã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰å³ ã‚’æŠ½å‡ºã—ã¦viewerã«è¡¨ç¤ºã™ã‚‹ã¾ã§ã®ãƒ•ãƒ­ãƒ¼ã¯ã“ã®ã‚ˆã†ã«ãªã£ã¦ã„ã¾ã™ã€‚
![main_flow.png](/images/a1f4c292a469b8/main_flow.png)

## å³ ã®å€™è£œã«ãªã‚‹é“è·¯åŒºé–“ã‚’å–å¾—

ã¾ãšå³ ã®å€™è£œã«ãªã‚‹åŒºé–“(LineString)ã®ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™ã€‚ã“ã®åŒºé–“ãŒå¾Œç¶šã§è¡Œã†è©•ä¾¡ãƒ­ã‚¸ãƒƒã‚¯ã®å¯¾è±¡ã«ãªã‚Šã¾ã™ã€‚
ã“ã‚Œã¯OpenStreetMapã®é“è·¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‹ã‚‰ä½œæˆã—ã¾ã™ã€‚
é“è·¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã«å¯¾ã—ã¦å³ ã®ç‰¹å¾´ã‚’æŒã¤å¯èƒ½æ€§ã®ã‚ã‚‹é“è·¯åŒºåˆ†ã§çµã‚Šè¾¼ã¿ã‚’ã‹ã‘ã¦æ®‹ã£ãŸãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒãƒ¼ãƒ‰ã®é–“ãŒå³ ã®å€™è£œã¨ãªã‚Šã¾ã™ã€‚

```python
# æŒ‡å®šãƒãƒªã‚´ãƒ³å†…ã®é“è·¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚’å–å¾—ã™ã‚‹
def fetch_graph(
    search_area_polygon : MultiPolygon,
) -> nx.Graph:
    ox.settings.useful_tags_way += ["yh:WIDTH"] + ["source"] + ["tunnel"] + ["bridge"]
    graph = ox.graph_from_polygon(
        search_area_polygon,
        network_type="drive",
        simplify=True,
        retain_all=True,
	      # é“è·¯åŒºåˆ†ã§æŠ½å‡º
        custom_filter='["highway"~"secondary|secondary_link|primary|primary_link|trunk|trunk_link|tertiary"]["lanes"!=1]',
    )
    return graph

```

| é“è·¯åŒºåˆ†ã§çµã‚Šè¾¼ã‚“ã ã‚‚ã®                                                                                                                       | å³ ã®å€™è£œ                                                                                                                                       |
| ---------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| ![é“è·¯åŒºåˆ†ã§çµã‚Šè¾¼ã‚“ã ã‚‚ã®ã€‚ã“ã®ãƒãƒ¼ãƒ‰ã¨ãƒãƒ¼ãƒ‰ã®é–“ãŒå³ ã®å€™è£œã®åŒºé–“](/images/a1f4c292a469b8/image4.png)_ã“ã®ãƒãƒ¼ãƒ‰ã¨ãƒãƒ¼ãƒ‰ã®é–“ãŒå³ ã®å€™è£œã®åŒºé–“_ | ![ãƒãƒ¼ãƒ‰é–“ã®LineStringã‚’æŠœãå‡ºã—ãŸã‚‚ã®ã€‚ã“ã‚ŒãŒå³ ã®å€™è£œåŒºé–“ã€‚](/images/a1f4c292a469b8/image5.png)_ãƒãƒ¼ãƒ‰é–“ã®LineStringã®ä¸€è¦§ã€‚ã“ã‚ŒãŒå³ ã®å€™è£œã€‚_ |

## äº¤å·®ç‚¹ãŒå¤šã„é“ã‚’å¼¾ã

äº¤å·®ç‚¹ãŒå¤šã„ã¨ã„ã†äº‹ã¯è„‡é“ã‹ã‚‰ã®é£›ã³å‡ºã—ã‚„æ­©è¡Œè€…ã«æ„è­˜ãŒæŒã£ã¦ã„ã‹ã‚Œã¦ã—ã¾ã™ã€‚ã“ã®ã‚ˆã†ãªé“ã¯é‹è»¢ã«é›†ä¸­ã§ãã¾ã›ã‚“ã€‚
ã•ãã»ã©ã®ã€Œå³ ã®å€™è£œã«ãªã‚‹åŒºé–“ã€ã§å–å¾—ã—ãŸé“ã«ã¯äº¤å·®ç‚¹ã®æƒ…å ±ã‚’æŒã£ã¦ã„ãªã„ã®ã§LineStringå†…ã®å…¨ãƒã‚¤ãƒ³ãƒˆã¨é‡ãªã‚‹é“è·¯ã‚’æ¢ã™äº‹ã§äº¤å·®ç‚¹ã®æ•°ã‚’æ±‚ã‚ã‚‹äº‹ãŒã§ãã¾ã™ã€‚

```python
def generate(gdf: GeoDataFrame, search_area_polygon) -> Series:
	  # å…¨é“è·¯ã‚’å–å¾—
    graph = ox.graph_from_polygon(
        search_area_polygon,
        network_type="drive",
        simplify=True,
        retain_all=True,
    )
    all_nodes = ox.graph_to_gdfs(graph, nodes=True, edges=False)
    sindex_nodes = all_nodes.sindex
    # åˆ†å²æ•°ã‚’å–å¾—
    def func(row):
        sindex_matche_indexs = list(sindex_nodes.intersection(row.geometry.bounds))
        sindex_matche_nodes = all_nodes.iloc[sindex_matche_indexs]yå†…ã®ãƒãƒ¼ãƒ‰ã‹ã‚‰çµã‚Šè¾¼ã‚€ã®ã§ã‚ã£ã¡ã‚ƒã¯ã‚„ã„ã€‚
        matche_nodes = sindex_matche_nodes[sindex_matche_nodes.intersects(row.geometry)]
        result = matche_nodes["street_count"].sum() - (len(matche_nodes) * 2)
        return result
    tqdm.pandas()
    series = gdf.progress_apply(func, axis=1)
    return series
```

## å‘¨è¾ºã«å»ºç‰©ãŒå¤šã„é“ã‚’å¼¾ã

å‘¨è¾ºã«å»ºç‰©ãŒå¤šã„ã¨ã„ã†äº‹ã¯äººé–“ãŒä½ã‚“ã§ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã€äººé–“ã®é£›ã³å‡ºã—ã‚„è¦–ç·šã«æ„è­˜ãŒæŒã£ã¦ã„ã‹ã‚Œã¦ã—ã¾ã„ã¾ã™ã€‚ãã†ã„ã†é“ã¯æ°—åˆ†ãŒæ‚ªã„ã®ã§å¼¾ãã¾ã™ã€‚
å¼¾ããŸã‚ã®æ–¹æ³•ã¨ã—ã¦ã¯ã€OverTrueMapã‹ã‚‰å»ºç‰©ãƒãƒªã‚´ãƒ³ã‚’å–å¾—ã—ã¦å€™è£œåŒºé–“ã®å‘¨è¾ºã®å»ºç‰©ã®æ•°ã‚’è¨ˆç®—ã—ã¾ã™ã€‚å»ºç‰©ãƒãƒªã‚´ãƒ³ã¯OpenStreetMapã«ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã™ãŒOverTrueMapã¯å†…éƒ¨ã«OpenStreetMapã¨Microsoftã®æ©Ÿæ¢°å­¦ç¿’ã§ä½œã‚‰ã‚ŒãŸå»ºç‰©ãƒãƒªã‚´ãƒ³ãŒæ··åœ¨ã—ã¦ã„ã‚‹ã®ã§ãƒ‡ãƒ¼ã‚¿æ•°ãŒå¤šã„ã“ã£ã¡ã‚’ä½¿ã£ãŸã»ã†ãŒã‚ˆã„ã§ã™ã€‚
OverTureMapsã®å»ºç‰©ãƒãƒªã‚´ãƒ³ã¯[ã“ã¡ã‚‰](https://docs.overturemaps.org/getting-data/athena-aws/)ã‹ã‚‰DLã§ãã¾ã™ã€‚DLã—ãŸç‰©ã‚’ãƒ­ãƒ¼ã‚«ãƒ«ã®PostGISã«æŒ¿å…¥ã—ã¦pythonã‹ã‚‰æ‰±ã„ã‚„ã™ã„ã‚ˆã†ãªå½¢ã«èª¿æ•´ã—ã¦ãŠãã¾ã™ã€‚
å…·ä½“çš„ãªè¨ˆç®—æ–¹æ³•ã¯ã€å€™è£œåŒºé–“ã®é“è·¯ã‹ã‚‰å‚ç›´ã«15mã®æ³•ç·šã‚’ä¼¸ã°ã—ã¦ãã®ä¸­ã«å«ã¾ã‚Œã‚‹å»ºç‰©ãƒãƒªã‚´ãƒ³æ•°ã‚’è¨ˆç®—ã—ã€ãã‚Œã‚’å‘¨è¾ºã®æ•°ã¨ã—ã¾ã—ãŸã€‚

èµ¤ã„ã‚„ã¤ãŒå€™è£œåŒºé–“å‘¨è¾ºã®å»ºç‰©ãƒãƒªã‚´ãƒ³ã§ã™ã€‚

![image.png](/images/a1f4c292a469b8/image6.png =400x)

```python
def main(line: LineString):
    bbox = line.bounds
    # LinStringã‹ã‚‰ä¸Šä¸‹ã«15må‚ç›´ã«ä¼¸ã°ã—ãŸãƒãƒªã‚´ãƒ³ã‚’ä½œæˆã™ã‚‹ã€‚
    polygon = create_vertical_polygon(line.coords, 15)
    # LineStirngã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹å†…ã®å»ºç‰©ã‚’å–å¾—
    buildings = get_nearby_builgings(bbox[0], bbox[1], bbox[2], bbox[3])
    # ãƒãƒªã‚´ãƒ³å†…ã®å»ºç‰©ã‚’å–å¾—
    match_buildings = []
    for index, building in enumerate(buildings):
        if building.intersects(polygon):
            match_buildings.append(building)
    unique_buildings = list(dict.fromkeys(match_buildings))
    # è¡¨ç¤º
    fig, ax = plt.subplots(figsize=(12, 8))
    ax.plot(*line.xy, color="blue", label="LineString")
    x, y = polygon.exterior.xy
    ax.fill(x, y, color="cyan", alpha=0.3, label="Polygon (Buffer)")
    label_added = False
    for building in unique_buildings:
        if building.geom_type == "Polygon":  # å»ºç‰©ãŒPolygonã®å ´åˆ
            x, y = building.exterior.xy
            ax.fill(x, y, color="red", alpha=0.5, label="Building (Polygon)" if not label_added else "")
            label_added = True
    ax.set_title("LineString, Polygon, and Buildings")
    ax.set_xlabel("Longitude")
    ax.set_ylabel("Latitude")
    ax.legend()
    plt.show()

# è¿‘ãã®å»ºç‰©ã‚’å–å¾—ã™ã‚‹
def get_nearby_builgings(min_longitude, min_latitude, max_longitude, max_latitude):
    session = get_db_session()
    try:
        buildings = []
        # SQLã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œ
        query = text(f"""
        SELECT ST_AsText(geometry) as geometry
        FROM buildings
        WHERE ST_Intersects(
        geometry,
        ST_MakeEnvelope(:min_longitude, :min_latitude, :max_longitude, :max_latitude, :srid)
        );
        """)
        result = session.execute(query, {
            'min_longitude': min_longitude,
            'min_latitude': min_latitude,
            'max_longitude': max_longitude,
            'max_latitude': max_latitude,
            'srid': 4326
        })
        result = result.fetchall()
        for data in result:
            geometry = wkt.loads(data[0])
            buildings.append(geometry)
    finally:
        session.close()
    return buildings
line =[[35.6654192,138.6443673],[35.6654624,138.6443208],[35.6655902,138.6441203],[35.6656294,138.6439655]]
coordinates = [(lon, lat) for lat, lon in line]
main(LineString(coordinates))
```

## äº¤é€šé‡ãŒå¤šã„é“ã‚’å¼¾ã

äº¤é€šé‡ãŒå¤šã„é“ã¯å‰å¾Œã®è»Šã«æ„è­˜ãŒæŒã£ã¦ã„ã‹ã‚Œã¦ã—ã¾ã„é‹è»¢ã«é›†ä¸­ã§ãã¾ã›ã‚“ã€‚
ã“ã‚Œã«ã¤ã„ã¦ã¯ãƒ­ã‚¸ãƒƒã‚¯ã‚’çµ„ã‚€å¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã“ã‚Œã¾ã§ã®å‡¦ç†ã®ã€Œå‘¨è¾ºã«å»ºç‰©ãŒå¤šã„é“ã‚’å¼¾ãã€ã€ã€Œäº¤å·®ç‚¹ãŒå¤šã„é“ã‚’å¼¾ãã€ã¨ã“ã®å…ˆã«è¡Œã†ã€Œ3æ¬¡å…ƒçš„ã«è¤‡é›‘ãªé“ã€ã§çµã‚Šè¾¼ã¿ã‚’è¡Œã†ã¨ãã®é“ã¯äº¤é€šé‡ãŒå°‘ãªã„é“ã«ãªã‚Šã¾ã™ã€‚
å³ é“ã¯åŸºæœ¬äº¤é€šé‡ãŒå°‘ãªã„ã®ã§è¨ˆç®—ã‚ãªãã¦ã‚‚ãã‚Œä»¥å¤–ã®è¦ç´ ã§çµã‚Šè¾¼ã‚€ã¨çµæœçš„ã«äº¤é€šé‡ãŒå°‘ãªããªã‚Šã¾ã—ãŸã€‚

## è»Šå¹…ãŒã‚ã‚‹ç¨‹åº¦ç¢ºä¿ã•ã‚Œã¦ã„ã‚‹é“ã‚’è©•ä¾¡

è»Šå¹…ãŒã‚ã‚‹ç¨‹åº¦ç¢ºä¿ã•ã‚Œã¦ã‚‹é“ã¯å¯¾å‘è»Šã‚’æ°—ã«ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã›ã‚“ã€‚è»Šå¹…ãŒç‹­ã2å°ã®è»ŠãŒåŒæ™‚ã«é€šã‚Œãªã„ã‚ˆã†ãªé“ã¯å¸¸ã«å¯¾å‘è»Šã«æ„è­˜ã‚’é›†ä¸­ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚Šé‹è»¢ã«é›†ä¸­ã§ãã¾ã›ã‚“ã€‚
å³ ã«ãŠã„ã¦ã“ã®è»Šå¹…ã¯é‡è¦ãªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼ã§ã“ã®åˆ¤åˆ¥ãŒã§ããªã„ã¨é…·é“ãŒå¼•ã£ã‹ã‹ã£ã¦ã—ã¾ã„ã¾ã™ã€‚
![é…·é“](/images/a1f4c292a469b8/image7.png)
_é…·é“_
[åˆ¥ã®è¨˜äº‹](https://zenn.dev/homing/articles/4127b8580bbfcf)ã§ã‚‚æ›¸ãã¾ã—ãŸãŒã‚ªãƒ¼ãƒ—ãƒ³ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é“å¹…ã‚’æ­£ç¢ºã«åˆ¤åˆ¥ã™ã‚‹äº‹ã¯é›£ã—ã„ã®ã§è‡ªå‰ã§ä½œã£ãŸè»Šç·šæ•°ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰è»Šå¹…ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
è»Šå¹…ã®è¨ˆç®—æ–¹æ³•ã¯å€™è£œåŒºé–“å†…ã®åº§æ¨™ã¨ä¸€è‡´ã™ã‚‹è»Šç·šãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã€ãã®ãƒ‡ãƒ¼ã‚¿æ•°ã¨è»Šç·šæ•°ã®å¹³å‡ã‹ã‚‰è¨ˆç®—ã—ã¾ã—ãŸã€‚
https://zenn.dev/homing/articles/4127b8580bbfcf

| è‡ªå‰ã§ä½œã£ãŸè»Šç·šãƒ‡ãƒ¼ã‚¿                                                                                                                         |                                                                                                                      |
| ---------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| ![è‡ªå‰ã§ä½œã£ãŸè»Šç·šãƒ‡ãƒ¼ã‚¿ã€‚é’: 2è»Šç·š, ã‚ªãƒ¬ãƒ³ã‚¸: 1.5è»Šç·š, èµ¤: 1è»Šç·š](/images/a1f4c292a469b8/image8.png)_é’: 2è»Šç·š, ã‚ªãƒ¬ãƒ³ã‚¸: 1.5è»Šç·š, èµ¤: 1è»Šç·š_ | ![è‡ªå‰ã§ä½œã£ãŸè»Šç·šãƒ‡ãƒ¼ã‚¿ã€‚](/images/a1f4c292a469b8/image9.png)_â†ã‚’ã‚ºãƒ¼ãƒ ã—ãŸã‚‚ã®ã€‚1åº§æ¨™æ¯ã«è»Šç·šã®æƒ…å ±ã‚’æŒã£ã¦ã„ã‚‹ã€‚_ |

```python
def main(line: LineString):
    coords = list(line.coords)
    # LineStringã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’å–å¾—
    min_longitude, min_latitude, max_longitude, max_latitude = line.bounds
    srid = 4326
    session = get_db_session()
    # ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    result = session.execute(text(f"SELECT ST_X(point) AS longitude, ST_Y(point) AS latitude, road_width_type  FROM locations WHERE ST_Intersects(ST_MakeEnvelope({min_longitude}, {min_latitude}, {max_longitude}, {max_latitude}, {srid}), locations.point)"))
    result = result.fetchall()
    # LineStringã¨ä¸€è‡´ã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®ã¿å–ã‚Šå‡ºã™
    match_width_data = []
    for coord in coords:
        for data in result:
            if data.longitude == coord[0] and data.latitude == coord[1]:
                match_width_data.append(data._asdict())
    # ä¸€è‡´ã—ãŸè»Šç·šãƒ‡ãƒ¼ã‚¿ã‚’å…ƒã«ã‚¹ã‚³ã‚¢ã‚’è¨ˆç®—(1ã«è¿‘ã„ã»ã©2è»Šç·šã«è¿‘ã„
    #   2è»Šç·š(TWO_LANE) = 1
    #   1.5è»Šç·š(ONE_LANE_SPACIOUS) = 0.5
    #   1è»Šç·š(ONE_LANE) = 0.01
    score = 0
    for width_data in match_width_data:
        if width_data['road_width_type'] == "TWO_LANE" or width_data['road_width_type'] == "TWO_LANE_SHOULDER":
            score += 1
        elif width_data['road_width_type'] == "ONE_LANE_SPACIOUS":
            score += 0.5
        elif width_data['road_width_type'] == "ONE_LANE":
            score += 0.01
    # ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
    print(score/len(match_width_data))
line =[[35.6654192,138.6443673],[35.6654624,138.6443208],[35.6655902,138.6441203],[35.6656294,138.6439655]]
coordinates = [(lon, lat) for lat, lon in line]
main(LineString(coordinates))
```

## é“è·¯ã®æ¨™é«˜å€¤ã‚’è¨ˆç®—ã™ã‚‹

å›½åœŸåœ°ç†é™¢ã‹ã‚‰æ—¥æœ¬å›½åœŸã®æ¨™é«˜ãƒ¢ãƒ‡ãƒ«ãŒå…¬é–‹ã•ã‚Œã¦ã„ã¾ã™ãŒã“ã®ãƒ¢ãƒ‡ãƒ«ã¯åœ°çƒè¡¨é¢ã®æ¨™é«˜å€¤ã§ã™ã€‚
ä»¥ä¸‹ã¯[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://maps.gsi.go.jp/help/pdf/demapi.pdf)ã‹ã‚‰æŠœç²‹

```jsx
åœ°è¡¨é¢ã®æ¸¬å®šå€¤ã«åŸºã¥ã„ã¦ã„ã‚‹ãŸã‚ã€æ§‹é€ ç‰©ï¼ˆå»ºç‰©ã€é«˜æ¶æ©‹ç­‰ï¼‰ã®é«˜ã•ã‚’åæ˜ ã—
ãŸã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
```

ä»Šå›å¿…è¦ãªæ¨™é«˜å€¤ã¯åœ°çƒé¢ã®æ¨™é«˜å€¤ã§ã¯ãªãé“è·¯ã®æ¨™é«˜å€¤ã§ã™ã€‚
ãã®ãŸã‚åœ°çƒé¢ã®æ¨™é«˜å€¤ã‹ã‚‰è£œæ­£ã‚’ã‹ã‘é“è·¯ã®æ¨™é«˜å€¤ã‚’è¨ˆç®—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

ã“ã¡ã‚‰ã¯è£œæ­£ã‚’ã‹ã‘ãšã«é“è·¯åŒºé–“å†…ã®å„åº§æ¨™ã‹ã‚‰å›½åœŸåœ°ç†é™¢ã®æ¨™é«˜ãƒ¢ãƒ‡ãƒ«ã®æ¨™é«˜å€¤ã‚’å–å¾—ã—ã¦three.jsã«æç”»ã—ãŸã‚‚ã®ã§ã™ã€‚é“è·¯ã®å½¢çŠ¶ã«ãªã£ã¦ã„ã¾ã›ã‚“ã­ã€‚

![ã‚Šã‚“ã”ã®çš®ã¿ãŸã„ãªå½¢çŠ¶ã‚’ã—ã¦ã¾ã™ã€‚](/images/a1f4c292a469b8/image10.png)
_ã‚Šã‚“ã”ã®çš®ã¿ãŸã„ãªå½¢çŠ¶ã‚’ã—ã¦ã¾ã™ã€‚_

è£œæ­£ã‚’ã‹ã‘ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã¯3ã¤ã§ã™ã€‚

1. ãƒˆãƒ³ãƒãƒ«åŒºé–“ã®è£œæ­£
2. æ©‹åŒºé–“ã®è£œæ­£
3. å›½ã®é“è·¯å‚¾æ–œã®åŸºæº–ã«ã‚ã‚ã›ãŸè£œæ­£

### ãƒˆãƒ³ãƒãƒ«åŒºé–“ã®è£œæ­£

OpenStreetMapã«ã¯ãƒˆãƒ³ãƒãƒ«ã®é–‹å§‹åœ°ç‚¹ã¨çµ‚äº†åœ°ç‚¹ã‚’æŒã£ã¦ã„ã¾ã™ã€‚ã“ã®é–“ã®æ¨™é«˜å€¤ãŒç·šå½¢ã«ãªã‚‹ã‚ˆã†ã«è£œæ­£ã—ã¾ã™ã€‚

```python
class InfraType(Enum):
    TUNNEL = 1
    BRIDGE = 2

# ãƒˆãƒ³ãƒãƒ«ã¨æ©‹ã®æ¨™é«˜å€¤ã‚’èª¿æ•´ã™ã‚‹
# gdf = è£œæ­£ã™ã‚‹LineStringã¨æ¨™é«˜å€¤ã‚’å«ã‚€GeoDataFrame
# infra_edges = æ©‹ã¨ãƒˆãƒ³ãƒãƒ«ã®åŒºé–“æƒ…å ±ã‚’å«ã‚€GeoDataFrame
# infraType = æ©‹ or ãƒˆãƒ³ãƒãƒ«
def generate(gdf: GeoDataFrame, infra_edges: GeoDataFrame, infraType: InfraType) -> Series:
    # ãƒˆãƒ³ãƒãƒ«ã®ç©ºé–“ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ä½œæˆ
    infra_edges_sindex = infra_edges["geometry"].sindex
    def func(row: GeoSeries):
        # row['bridge']ã¨row['tunnel']ã¯é…åˆ—ã¨æ–‡å­—åˆ—ã®ï¼’ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚ã‚Šã€‚
        if (
            infraType == InfraType.BRIDGE
            and not any(x in row['bridge'] for x in ['yes', 'aqueduct', 'boardwalk', 'cantilever', 'covered', 'low_water_crossing', 'movable', 'trestle', 'viaduct'])
        ):
            return row['elevation']
        if(
            infraType == InfraType.TUNNEL
            and not any(x in row['tunnel'] for x in ['yes', 'building_passage', 'avalanche_protector', 'culvert', 'canal', 'flooded'])
        ):
            return row['elevation']

        base_edge_coords = list(row.geometry.coords)
        # 1. å¯¾è±¡ã®ã‚¨ãƒƒã‚¸ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹å†…ã®ãƒˆãƒ³ãƒãƒ«ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—(ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã§ã®æŠ½å‡ºãªã®ã§ã‚¨ãƒƒã‚¸å¤–ã®ãƒˆãƒ³ãƒãƒ«ã‚‚å«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹)
        infra_edge_in_bbox_index_list = list(infra_edges_sindex.intersection(row.geometry.bounds))
        # 2. ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒˆãƒ³ãƒãƒ«ã®ã‚¨ãƒƒã‚¸ã‚’å–å¾—
        infra_edges_in_bbox = infra_edges.iloc[infra_edge_in_bbox_index_list]
        # 3. å¯¾è±¡ã®ã‚¨ãƒƒã‚¸ã¨é‡ãªã‚‹ã‚¤ãƒ³ãƒ•ãƒ©ã®ã¿ã‚’æŠ½å‡º(ä¸€æ—¦åº§æ¨™ãŒ2ä»¥ä¸Šé‡ãªã£ã¦ã„ã‚‹ã‹ã§åˆ¤æ–­)
        target_infra_index_list = []
        for idx, infra_edge in infra_edges_in_bbox.iterrows():
            num_match_coords = sum([1 for coord in infra_edge.geometry.coords if coord in base_edge_coords])
            if num_match_coords >= 2:
                target_infra_index_list.append(idx)
        if len(target_infra_index_list) == 0:
            return row['elevation']
        target_infra_edges = infra_edges_in_bbox.loc[target_infra_index_list]

        # å§‹ç‚¹ã¨çµ‚ç‚¹ãŒç·šå½¢ã«ãªã‚‹ã‚ˆã†ã«æ¨™é«˜ã‚’èª¿æ•´
        elevation_adjusted = row.elevation.copy()
        for i, infra_edge in target_infra_edges.iterrows():
            infra_coords = list(infra_edge.geometry.coords)
            road_coords = list(row.geometry.coords)
            nearest_outside_start = get_nearest_outside_point(road_coords, infra_coords[0], infra_coords)
            nearest_outside_end = get_nearest_outside_point(road_coords, infra_coords[-1], infra_coords)
            a_idx = base_edge_coords.index(nearest_outside_start)
            b_idx = base_edge_coords.index(nearest_outside_end)
            start_idx = min(a_idx, b_idx)
            end_idx = max(a_idx, b_idx)
            def linear_interpolation(arr, start_idx, end_idx) -> List[int]:
                start_value = arr[start_idx]
                end_value = arr[end_idx]
                num_points = end_idx - start_idx + 1
                interpolated_values = np.linspace(start_value, end_value, num_points)
                interpolated_values_list = list(interpolated_values)
                for i, value in enumerate(interpolated_values_list):
                    arr[start_idx + i] = value
                return arr
            elevation_adjusted = linear_interpolation(elevation_adjusted, start_idx, end_idx)
        return elevation_adjusted
    results = gdf.apply(func, axis=1)
    return results

# ãƒˆãƒ³ãƒãƒ«å¤–ã§æœ€ã‚‚è¿‘ã„åº§æ¨™ã‚’å–å¾—
def get_nearest_outside_point(road_coords: list, point: Tuple[float, float] , infra_coords: list):
    if road_coords == infra_coords:
        return min(road_coords, key=lambda x: Point(x).distance(Point(point)))
    road_coords_without_infras = []
    infra_coords_without_first_and_last = infra_coords[1:-1]
    if not len(infra_coords_without_first_and_last) == 0:
        road_coords_without_infras += [coord for coord in road_coords if not coord in infra_coords_without_first_and_last]  # ä¸­é–“ã®ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
    else:
        road_coords_without_infras = road_coords
    # æŒ‡å®šåº§æ¨™(point)ã«æœ€ã‚‚è¿‘ã„åº§æ¨™ã‚’å–å¾—
    nearest_point = min(road_coords_without_infras, key=lambda x: Point(x).distance(Point(point)))
    if nearest_point == (135.1666045, 34.699294):
        pass
    return nearest_point
```

ã‚ã‚‹ç¨‹åº¦è£œæ­£ã§ãã¾ã—ãŸãŒã¾ã ã¾ã å‡¹å‡¸ãŒã‚ã‚‹çŠ¶æ…‹ã§ã™ã€‚

![image.png](/images/a1f4c292a469b8/image11.png)

### å›½ã®é“è·¯å‚¾æ–œã®åŸºæº–ã«ã‚ã‚ã›ã‚‹

é“è·¯å‚¾æ–œã®åŸºæº–ã¯[å›½ã®é“è·¯æ§‹é€ ä»¤ã®ç¬¬åå…­æ¡](https://laws.e-gov.go.jp/law/345CO0000000320/#156)ã«æ›¸ã‹ã‚Œã¦ãŠã‚Šã€ç”Ÿæ´»é“è·¯ã‚’é™¤ãä¸€èˆ¬çš„ãªé“è·¯ã¯ã€Œæœ€å¤§10%ã€ã¨ã•ã‚Œã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯100mã‚ãŸã‚Šæœ€å¤§10mã®å‹¾é…ã¾ã§ãªã‚‰OKã¨ã„ã†äº‹ã«ãªã‚Šã¾ã™ã€‚
ã“ã®åŸºæº–ã«é©åˆã™ã‚‹ã‚ˆã†ã«è£œæ­£ã‚’ã‹ã‘ã¾ã™ã€‚

```python
from geopandas import GeoDataFrame
from pandas import Series
from geopy.distance import geodesic

# å›½åŸºåŸºæº–ã ã¨100mã‚ãŸã‚Š10%ã¾ã§OKã ãŒä¸€æ—¦8%ã¨ã™ã‚‹ã€‚
METER_AND_ELEVATION_RATIO = 0.08

# å›½ã®åŸºæº–ã«åˆã‚ã›ã¦æ¨™é«˜å€¤ã‚’è£œæ­£ã™ã‚‹
# gdf = è£œæ­£ã™ã‚‹LineStringã¨æ¨™é«˜å€¤ã‚’å«ã‚€GeoDataFrame
def generate(gdf: GeoDataFrame) -> Series:
    def func(row):
        line = row.geometry
        elevations = row.elevation
        slope_per_meter_list = []
        for index, point in enumerate(line.coords):
            elevation = elevations[index]
            if index + 1 < len(line.coords):
                next_point = line.coords[index + 1]
                next_point_elevation = elevations[index + 1]
                distance = geodesic((point[1], point[0]), (next_point[1], next_point[0])).meters
                elevation_diff = abs(elevation - next_point_elevation)
                slope_per_meter = elevation_diff / distance
                slope_per_meter_list.append(slope_per_meter)
                if slope_per_meter > METER_AND_ELEVATION_RATIO:
                    if elevation < next_point_elevation:
                        adjust_next_elevation = elevation + (distance * METER_AND_ELEVATION_RATIO)
                    else:
                        adjust_next_elevation = elevation - (distance * METER_AND_ELEVATION_RATIO)
                        if adjust_next_elevation < 0:
                            adjust_next_elevation = 0
                    elevations[index + 1] = adjust_next_elevation
        return elevations
    series = gdf.apply(func, axis=1)
    return series
```

è£œæ­£ã‚’ã‹ã‘ã‚‹ã¨ã ã„ã¶é“è·¯ã®ã‚ˆã†ãªå½¢çŠ¶ã«ãªã‚Šã¾ã—ãŸã€‚
![ã„ã„æ„Ÿã˜](/images/a1f4c292a469b8/image12.png =500x)

### æ©‹ã®åŒºé–“ã‚’è£œæ­£

OpenStreetMapã‹ã‚‰æ©‹ã®åŒºé–“ã‚‚å–å¾—ã§ãã‚‹ã®ã§ãƒˆãƒ³ãƒãƒ«ã¨åŒæ§˜ã®æ‰‹é †ã§ç·šå½¢çš„ã«è£œæ­£ã‚’ã‹ã‘ã¾ã™ã€‚
![é“è·¯ãŒæµ®ã„ã¦ã„ã¦æ©‹ã£ã½ã„ã€‚](/images/a1f4c292a469b8/image13.png)
ã“ã“ã¾ã§ã®è£œæ­£ã§é“è·¯ã®æ¨™é«˜å€¤ã‚’å–å¾—ã™ã‚‹äº‹ãŒã§ãã¾ã—ãŸã€‚
ã“ã®æ¨™é«˜å€¤ã‹ã‚‰ã€Œå‹¾é…ãŒã¤ã„ã¦ã„ã‚‹é“è·¯ã€ã¨ã€Œæ³¢æ‰“ã¤ã‚ˆã†ãªã®å‚é“ã€ã®åˆ¤å®šã‚’è¡Œã„ã¾ã™ã€‚

ä½™è«‡ã§ã™ãŒã€å›½åœŸåœ°ç†é™¢ã‹ã‚‰æ¨™é«˜å€¤ã‚’å–å¾—ã™ã‚‹å ´åˆã¯APIã‚’ä½¿ã‚ãšã«ãƒ­ãƒ¼ã‚«ãƒ«ã«ç’°å¢ƒã‚’ä½œã£ã¦ãŠãäº‹ã‚’ãŠã™ã™ã‚ã—ã¾ã™ã€‚
https://zenn.dev/homing/articles/541ffbf8e5f64c

## å‹¾é…ãŒã¤ã„ã¦ã„ã‚‹é“ã®è©•ä¾¡

å³ ã®é†é†å‘³ã¯å‹¾é…ã§ã™ã€‚
å‹¾é…ã®è©•ä¾¡æ–¹æ³•ã¯ç°¡å˜ã§ã€å€™è£œåŒºé–“å†…ã§æ¨™é«˜å€¤ã®é«˜ä½å·®ã‚’æ±‚ã‚ã¦ãã®å€¤ã®å¤§ãã•ã‹ã‚‰å‹¾é…ãŒã¤ã„ã¦ã„ã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚
ã§ã™ãŒå‹¾é…ã¯ãŸã ã¤ã„ã¦ã„ã‚Œã°ã„ã„ã‚‚ã®ã§ã¯ãªãã€ã‚ã‚‹ä¸€å®šä»¥ä¸Šã¯é‹è»¢ã—ã¥ã‚‰ããªã£ã¦ã—ã¾ã„ã¾ã™ã€‚ãã®ãŸã‚äº‹å‰ã«é‹è»¢ã—ã‚„ã™ã„é«˜ä½å·®ã®ç¯„å›²ã‚’æ±ºã‚ã¦ã€ãã®ç¯„å›²å†…ã«åã¾ã‚‹ãªã‚‰è©•ä¾¡ã‚’ä¸Šã’ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚
ä»Šå›ã¯é«˜ä½å·®ãŒ30~300mã®ç¯„å›²å†…ã‚’è‰¯ã„å‹¾é…ã¨è©•ä¾¡ã—500mã‚’è¶…ãˆã‚‹å ´åˆã¯è©•ä¾¡å€¤ã‚’ä¸‹ã’ã‚‹ã‚ˆã†ã«ã—ã¾ã—ãŸã€‚

| å‹¾é…ãŒå¤§ãã™ãã‚‹é“                                                                                             | ã»ã©ã‚ˆã„å‹¾é…ã®é“                                          |
| -------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------- |
| ![å‹¾é…ãŒå¤§ãã™ãã‚‹é“ã€‚ç¸¦è»¸(æ¨™é«˜): 1ç›®ç››ã‚Š=1m, æ¨ªè»¸(é“ã®è·é›¢): 1ç›®ç››ã‚Š=50m](/images/a1f4c292a469b8/image14.png) | ![ã»ã©ã‚ˆã„å‹¾é…ã®é“ã€‚](/images/a1f4c292a469b8/image15.png) |

```python
# å‹¾é…ã‚’è©•ä¾¡ã™ã‚‹
def generate(gdf: GeoDataFrame) -> Series:
    def func(row):
        # æ¨™é«˜ã®é«˜ä½å·®ã‚’æ±‚ã‚ã‚‹ã€‚
        elevation = row['elevation']
        min_elevation = min(elevation)
        max_elevation = max(elevation)
        elevation_height = max_elevation - min_elevation
        # é«˜ä½å·®ãŒ30m-300mã®ç¯„å›²ã‚’0.4~1ã®ç¯„å›²ã«å¤‰æ›
        old_min, old_max = 30, 300
        new_min, new_max = 0.4, 1
        initial_value = 0
        if elevation_height >= old_max:
            initial_value = 1
        else:
            initial_value = convert_range(elevation_height, old_min, old_max, new_min, new_max)
        # é«˜ä½å·®ãŒ500mä»¥ä¸Šã®å ´åˆã¯è©•ä¾¡å€¤ã‚’æ¸›ã‚‰ã™
        subtrahend = 0
        if elevation_height >= 500:
            old_min, old_max = 500, 1000
            new_min, new_max = 0.5, 1
            if elevation_height >= old_max:
                subtrahend = 1
            else:
                subtrahend = convert_range(elevation_height, old_min, old_max, new_min, new_max)
        return initial_value - subtrahend
    series = gdf.apply(func, axis=1)
    return series

def convert_range(value, old_min, old_max, new_min, new_max):
    return ((value - old_min) / (old_max - old_min)) * (new_max - new_min) + new_min

```

## æ³¢æ‰“ã¤ã‚ˆã†ãªå‚ãŒå¤šã„é“ã‚’è©•ä¾¡

æ³¢æ‰“ã¡å‚é“ã¨ã¯zè»¸æ–¹å‘ã«ã†ã­ã†ã­ã—ã¦ã„ã‚‹é“ã®äº‹ã§ã§ã™ã€‚
ã“ã†ã„ã£ãŸé“ã¯ä¸Šã‚ŠåŒºé–“ã€ä¸‹ã‚ŠåŒºé–“ã¨ã„ã£ãŸã‚ˆã†ã«åˆ†ã‘ã‚‹äº‹ãŒã§ãã¦è‡ªå‹•è»Šã®ç‰¹æ€§ãŒå¤§ããç¾ã‚Œã¾ã™ã€‚ãŸã¨ãˆã°ã€FF(å‰è¼ªé§†å‹•)ãªã‚‰ä¸‹ã‚ŠåŒºé–“ã§ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãŒã‹ã‹ã‚Šã€FR(å¾Œè¼ªé§†å‹•)ãªã‚‰ä¸Šã‚ŠåŒºé–“ã§ãƒˆãƒ©ã‚¯ã‚·ãƒ§ãƒ³ãŒã‹ã‹ã‚Šã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã†ã„ã£ãŸä¸Šã‚Šä¸‹ã‚ŠåŒºé–“ãŒæ··ã˜ã£ã¦ã„ã‚‹é“ã¯é§†å‹•æ–¹å¼ã«é–¢ä¿‚ãªãæ¥½ã—ã‚ã‚‹é“ã¨ã„ã†äº‹ã«ã‚‚ãªã‚Šã¾ã™ã€‚

| å˜ç´”ãªå‚                                        | æ³¢æ‰“ã¤ã‚ˆã†ãªå‚                                                                  |
| ----------------------------------------------- | ------------------------------------------------------------------------------- |
| ![å˜ç´”ãªå‚](/images/a1f4c292a469b8/image16.png) | ![æ³¢æ‰“ã¤ã‚ˆã†ãªå‚ã€‚ä¸Šã‚ŠåŒºé–“ã¨ä¸‹ã‚ŠåŒºé–“ã‚’å«ã‚€](/images/a1f4c292a469b8/image17.png) |

ã“ã®ä¸Šã‚Šã¨ä¸‹ã‚ŠåŒºé–“ã®æ•°ã‚’è¨ˆç®—ã—ã¾ã™ã€‚
è¨ˆç®—æ–¹æ³•ã¯Scripyã¨ã„ã†æ•°å€¤è§£æãƒ©ã‚¤ãƒ–ãƒ©ãƒªã§ãƒ‡ãƒ¼ã‚¿å†…ã®ãƒ—ãƒ­ãƒŸãƒãƒ³ã‚¹(ãƒ‡ãƒ¼ã‚¿ã®ä¸­ã§å°–ã£ã¦ã„ã‚‹éƒ¨åˆ†)ã‚’æ±‚ã‚ãã®æ•°ã®åˆè¨ˆã‚’æ±‚ã‚ã¾ã™ã€‚ãƒ—ãƒ­ãƒŸãƒãƒ³ã‚¹ã«ã¤ã„ã¦ã¯[ã“ã¡ã‚‰è¨˜äº‹](https://qiita.com/ku_a_i/items/b8bc00884b2290f897b4)ãŒã¨ã¦ã‚‚ã‚ã‹ã‚Šã‚„ã™ã„ã§ã™ã€‚
ä»¥ä¸‹ã¯å€™è£œåŒºé–“ã®æ¨™é«˜å€¤ã‹ã‚‰å°–ã£ã¦ã„ã‚‹ãƒã‚¤ãƒ³ãƒˆã‚’æ±‚ã‚ãŸç‰©ã§ã™ã€‚

![image.png](/images/a1f4c292a469b8/image18.png =600x)

```python
elevations= [0, 10, 4, 4, 3, 2, 1, 5, 4, 3, 2, 1, 1, 1, ,1......]
distance = 3
prominence = 5
# ä¸Šã‚ŠåŒºé–“ã®peakå€¤ã‚’å–å¾—
peaks, _ = find_peaks(elevations, distance=distance, prominence=prominence)
count = len(peaks)
print(count)
```

ãƒ—ãƒ­ãƒŸãƒãƒ³ã‚¹ã¯ãƒ‡ãƒ¼ã‚¿ã®å°–ã£ã¦ã„ã‚‹éƒ¨åˆ†ã‚’æ¤œå‡ºã™ã‚‹ã ã‘ãªã®ã§ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ã¨å‡¹ã¿ãŒæ¤œå‡ºã•ã‚Œã¾ã›ã‚“ã€‚
ãã®ãŸã‚é€†è»¢ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ã™ã‚‹äº‹ã§å‡¹ã¿ã‚’æ¤œå‡ºã—ã¾ã™ã€‚

![image.png](/images/a1f4c292a469b8/image19.png =600x)

```python
elevations= [0, 10, 4, 4, 3, 2, 1, 5, 4, 3, 2, 1, 1, 1, ,1......]
distance = 3
prominence = 5
# ä¸Šã‚ŠåŒºé–“ã®peakå€¤ã‚’å–å¾—
peaks, _ = find_peaks(elevations, distance=distance, prominence=prominence)

# ä¸‹ã‚ŠåŒºé–“ã®peakå€¤ã‚’å–å¾—
elevations_inverted = np.max(elevations) - elevations
peaks_inverted, _ = find_peaks(elevations_inverted, distance=3, prominence=5)

print(len(peaks) + len(peaks_inverted))
```

ã“ã‚Œã§ä¸Šã‚ŠåŒºé–“ã¨ä¸‹ã‚ŠåŒºé–“ã®æ•°ã‚’æ±‚ã‚ã‚‹äº‹ãŒã§ãã¾ã—ãŸã€‚
ã“ã®åŒºé–“æ•°ãŒå¤šã„é“ãŒã€Œæ³¢æ‰“ã¤ã‚ˆã†ãªå‚ãŒå¤šã„é“ã€ã¨ã„ã†äº‹ã«ãªã‚Šã¾ã™ã€‚

## å¤šæ§˜ãªã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆãŒæ··ã–ã£ãŸé“ã‚’è©•ä¾¡ã™ã‚‹

å³ é“ã¨æ€ã„æµ®ã‹ã¹ã‚‹ã¨ã‚³ãƒ¼ãƒŠãƒ¼ã®RãŒå¤§ãã„é“ã‚’æƒ³åƒã™ã‚‹ã¨æ€ã„ã¾ã™ãŒã€ãŸã å¤§ãã„ã ã‘ã ã¨å˜èª¿ã§é‹è»¢ã—ã¦ã¤ã¾ã‚‰ãªã„é“ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚
ãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã‚²ãƒ¼ãƒ ã‚’ã‚„ã£ãŸäº‹ãŒã‚ã‚‹æ–¹ãªã‚‰ã‚ã‹ã‚‹ã¨æ€ã„ã¾ã™ãŒã€ã‚³ãƒ¼ãƒŠãƒ¼ã®1ã¤1ã¤ã«é©åˆ‡ãªã‚¢ãƒ—ãƒ­ãƒ¼ãƒæ–¹æ³•ãŒã‚ã‚Šã€ãã‚Œã‚‰ã¯ã‚³ãƒ¼ãƒŠãƒ¼ç›´å‰ã®çŠ¶æ…‹ã«ã‚ˆã£ã¦å¤‰ã‚ã‚Šã¾ã™ã€‚ãªã®ã§å¤šæ§˜ãªå½¢çŠ¶ã‚’ã—ã¦ã„ã‚‹é“ã»ã©ã‚¢ãƒ—ãƒ­ãƒ¼ãƒæ–¹æ³•ãŒå¤šããªã‚Šæ¥½ã—ã„é“ã¨ãªã‚Šã¾ã™ã€‚
ã“ã®ã‚ˆã†ãªé“ã‚’åˆ¤åˆ¥ã™ã‚‹ãŸã‚ã«å¤šæ§˜ãªã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆãŒé©åˆ‡ã«æ··ã–ã‚Šè¾¼ã‚“ã é“ã‚’åˆ¤åˆ¥ã—ã¾ã™ã€‚
è¨ˆç®—æ–¹æ³•ã¨ã—ã¦ã¯ã€é“è·¯åŒºé–“ã®LineStringã‹ã‚‰é«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã‚’æ±‚ã‚ãã‚Œã‚‰ã®åŒºé–“è·é›¢ã®å‰²åˆãŒè¿‘ã„é“ã»ã©è©•ä¾¡ãŒä¸ŠãŒã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚
ä¸Šè¨˜ã‚’æ±‚ã‚ã‚‹ã«ã¯ã¾ãšå€™è£œåŒºé–“ã‚’è‡ªå‹•è»ŠãŒèµ°è¡Œã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®å¤‰åŒ–é‡ã‚’æ±‚ã‚ã€ãã®å›è»¢é‡ã‹ã‚‰ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã«åˆ†å‰²ã—ã¦ãã®å¾Œã«è·é›¢ã®å‰²åˆã‚’è©•ä¾¡ã—ã¾ã™ã€‚

### æŒ‡å®šåŒºé–“ã‚’è‡ªå‹•è»ŠãŒèµ°è¡Œã™ã‚‹ãŸã‚ã«å¿…è¦ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æ¨ç§»ã‚’æ±‚ã‚ã‚‹

ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã¯3åº§æ¨™æ¯ã«æ±‚ã‚ã¾ã™ã€‚
åŒºé–“é“è·¯ã®LineStringã‹ã‚‰å…ˆé ­3åº§æ¨™ã‚’æŠœãå‡ºã—ã¦ãã®3åº§æ¨™ã‚’é€šã‚‹å††ã®åŠå¾„ã‚’æ±‚ã‚ã¾ã™ã€‚ã“ã‚Œã¨è»Šã®å‰è¼ªã«èˆµè§’ãŒã¤ã„ãŸã¨ãã«è»ŠãŒå††ã‚’æã„ã¦å›è»¢ã™ã‚‹éš›ã®å††ã®åŠå¾„ãŒã‚¤ã‚³ãƒ¼ãƒ«ã«ãªã‚‹æ™‚ã®å‰è¼ªã®èˆµè§’é‡ã‚’æ±‚ã‚ã¾ã™ã€‚
ã“ã®èˆµè§’é‡ã¨è»Šã®ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã‚®ã‚¢æ¯”ã®ç©ã‚’æ±‚ã‚ã‚‹äº‹ã§è»ŠãŒ3åº§æ¨™é–“ã‚’èµ°è¡Œã™ã‚‹ã®ã«å¿…è¦ãªã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã‚’æ±‚ã‚ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
ä¸Šè¨˜å‡¦ç†ã‚’1åº§æ¨™ãšã¤ãšã‚‰ã—ãªãŒã‚‰å…¨åº§æ¨™ã®è¨ˆç®—ã‚’è¡Œã†äº‹ã§æŒ‡å®šåŒºé–“å†…ã®ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æ¨ç§»ãŒæ±‚ã¾ã‚Šã¾ã™ã€‚

| æŒ‡å®šåŒºé–“ã®å…ˆé ­3åº§æ¨™ã‚’é€šã‚‹å††ã®åŠå¾„                                              | è»Šã®å‰è¼ªã«èˆµè§’ãŒã¤ã„ãŸã¨ãã«è»ŠãŒå††ã‚’æã„ã¦å›è»¢ã™ã‚‹éš›ã®å††ã®åŠå¾„                                                                                                                                                                           |
| ------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![æŒ‡å®šåŒºé–“ã®å…ˆé ­3åº§æ¨™ã‚’é€šã‚‹å††ã®åŠå¾„](/images/a1f4c292a469b8/image20.png =500x) | ![è»Šã®å‰è¼ªã«èˆµè§’ãŒã¤ã„ãŸã¨ãã«è»ŠãŒå††ã‚’æã„ã¦å›è»¢ã™ã‚‹éš›ã®å††ã®åŠå¾„Rã€‚ã€Œ[autoexeã•ã‚“ã®ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°ã‚’æ¥½ã—ã‚€ãŸã‚ã®å‹•çš„æ„Ÿæ€§å·¥å­¦æ¦‚è«–ã€€Â§11](https://www.autoexe.co.jp/kijima/column11.html)ã€ã‹ã‚‰å¼•ç”¨](/images/a1f4c292a469b8/image21.png =500x) |

ã“ã‚“ãªæ„Ÿã˜ã§è¨ˆç®—ã§ãã¾ã™ã€‚

```python
import numpy as np

# 3åº§æ¨™ã‚’é€šéã™ã‚‹ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®è§’åº¦ã‚’è¨ˆç®—ã™ã‚‹ã‚µãƒ³ãƒ—ãƒ«
def main():
    # è‡ªå‹•è»Šã®æƒ…å ±(ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆã‚«ãƒ¼ã‚’æƒ³å®š)
    wheel_base = 2.5  # ãƒ›ã‚¤ãƒ¼ãƒ«ãƒ™ãƒ¼ã‚¹(m)
    steering_ratio = 15  # ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã‚®ã‚¢æ¯”(ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã¨ã‚¿ã‚¤ãƒ¤ã®å›è»¢æ¯”ç‡)
    # 3ç‚¹ã‚’é€šã‚‹å††ã®ä¸­å¿ƒã¨åŠå¾„ã‚’è¨ˆç®—
    p1 = np.array([0, 0])
    p2 = np.array([1, 1])
    p3 = np.array([2, 0])
    center, radius = calc_circle_center_and_radius(p1 ,p2, p3)
    # ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®åˆ‡ã‚Œè§’ã‚’è¨ˆç®—
    steering_angle = calc_steering_angle(wheel_base, radius, steering_ratio)
    # ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®å›è»¢æ–¹å‘ã‚’è¨ˆç®—(å·¦ã€å‰ã€å³)
    direction = calc_direction(p1, p2, p3)
    print(f"ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®åˆ‡ã‚Œè§’: {steering_angle:.2f}Â°, å›è»¢æ–¹å‘: {direction}")

# 3ç‚¹ã‚’é€šã‚‹å††ã®ä¸­å¿ƒã®åº§æ¨™ã¨åŠå¾„ã‚’è¨ˆç®—
def calc_circle_center_and_radius(p1, p2, p3):
    temp = p2[0]**2 + p2[1]**2
    bc = (p1[0]**2 + p1[1]**2 - temp) / 2
    cd = (temp - p3[0]**2 - p3[1]**2) / 2
    det = (p1[0] - p2[0]) * (p2[1] - p3[1]) - (p2[0] - p3[0]) * (p1[1] - p2[1])
    if abs(det) < 1.0e-10:
        # 3ç‚¹ãŒç›´ç·šä¸Šã«ã‚ã‚‹å ´åˆã¯ã‚¨ãƒ©ãƒ¼
        raise ValueError("Points are collinear")
    # å††ã®ä¸­å¿ƒ (cx, cy)
    cx = (bc * (p2[1] - p3[1]) - cd * (p1[1] - p2[1])) / det
    cy = ((p1[0] - p2[0]) * cd - (p2[0] - p3[0]) * bc) / det
    # åŠå¾„
    radius = np.sqrt((cx - p1[0])**2 + (cy - p1[1])**2)
    return (cx, cy), radius

# ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°åˆ‡è§’ã‚’è¨ˆç®—
def calc_steering_angle(wheelbase, radius, steering_ratio):
    tire_angle = 90 - (np.arccos(wheelbase / radius) * (180 / np.pi))  # ã‚¿ã‚¤ãƒ¤ã®èˆµè§’ã‚’è¨ˆç®—
    steering_wheel_angle = tire_angle * steering_ratio  # ã‚¿ã‚¤ãƒ¤ã®èˆµè§’ã‚’ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®èˆµè§’ã«å¤‰æ›
    return steering_wheel_angle

# ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®å›è»¢æ–¹å‘ã‚’è¨ˆç®—
def calc_direction(pm1, p2, p3):
    det = (p2[0] - pm1[0]) * (p3[1] - p2[1]) - (p2[1] - pm1[1]) * (p3[0] - p2[0])
    if det > 0:
        direction = "left"
    elif det < 0:
        direction = "right"
    else:
        direction = "straight"
    return direction
```

```jsx
// ä¸Šè¨˜ãƒ­ã‚¸ãƒƒã‚¯ã§æ±‚ã‚ãŸæŒ‡å®šåŒºé–“ã®LineString[A, B, C, D, E]ã®ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æ¨ç§»ãƒ‡ãƒ¼ã‚¿
[
  {
    start: [137.0004442, 35.3744692],
    center: [137.0004336, 35.3745886],
    end: [137.00041195, 35.37470605],
    steering_angle: 1.9882090936,
    radius: 1080.6678508533,
    distance: 26.4795107773,
    direction: "left",
  },
  {
    start: [137.00041195, 35.37470605],
    center: [137.0003903, 35.3748235],
    end: [137.00037985, 35.3749338],
    steering_angle: 0.5740575027,
    radius: 3742.8164974385,
    distance: 25.4709822213,
    direction: "right",
  },
  {
    start: [137.00037985, 35.3749338],
    center: [137.0003694, 35.3750441],
    end: [137.00043275, 35.3751771],
    steering_angle: 59.5237431153,
    radius: 36.1252554475,
    distance: 28.1335727288,
    direction: "right",
  },
];
```

### é«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã‚’æ±‚ã‚ã¦è¤‡é›‘æ€§ã®é«˜ã„é“ã‚’æ±‚ã‚ã‚‹

ç›´å‰ã«æ±‚ã‚ãŸã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æƒ…å ±ã‹ã‚‰é«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã‚’æ±‚ã‚ã¾ã™ã€‚
è¨ˆç®—æ–¹æ³•ã¯ã€ç›´å‰ã§æ±‚ã‚ãŸã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æƒ…å ±ã‹ã‚‰é€£ç¶šã™ã‚‹å›è»¢æ–¹å‘ã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦ã‚°ãƒ«ãƒ¼ãƒ—æ¯ã«å›è»¢é‡ãŒæœ€ã‚‚å¤§ãã„å€¤ã‚’æŠœãå‡ºã—ã¾ã™ã€‚ãã®å€¤ã‹ã‚‰ã‚°ãƒ«ãƒ¼ãƒ—ãŒé«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã‹ã©ã†ã‹ã®åˆ¤åˆ¥ã‚’è¡Œã„ã€ã“ã®4è¦ç´ ã®è·é›¢ã®å¤§ãã•ãŒè¿‘ã„é“ãŒè¤‡é›‘æ€§ã®é«˜ã„é“ã¨ãªã‚Šã¾ã™ã€‚

:::details ã‚³ãƒ¼ãƒ‰ã¯é•·ã„ã®ã§æŠ˜ã‚ŠãŸãŸã¿ã¾ã™ã€‚
ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æ¨ç§»ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰é€£ç¶šã™ã‚‹ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢æ–¹å‘æ¯ã«å³ã‚³ãƒ¼ãƒŠãƒ¼ã€å·¦ã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã§ã‚°ãƒ«ãƒ¼ãƒ—åŒ–

```python
# 3ç‚¹ã®ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æ¨ç§»ã®æƒ…å ±ã‹ã‚‰å³ã‚³ãƒ¼ãƒŠãƒ¼ã€å·¦ã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã‚’ä½œæˆã™ã‚‹
STRAIGHT_DISTANCE = 100 # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã¯100mç¶šãå ´åˆã®ã¿ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã¨ã™ã‚‹ã€‚100mä»¥ä¸‹ã®å ´åˆã¯å‰å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã«åˆ†é…ã—ã¦çµåˆã™ã‚‹ã€‚
STRAIGHT_ANGLE = 7 # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®æœ€å¤§ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°åˆ‡ã‚Œè§’
def generate(gdf: GeoDataFrame) -> Series:
    def func(row):
        # é€£ç¶šã™ã‚‹å·¦ã‚³ãƒ¼ãƒŠãƒ¼ã€å³ã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã™ã‚‹
        sections = group_continuous_section(row['steering_wheel_angle_info'])
        # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆåŒºé–“ãŒ100mæœªæº€ã®å ´åˆã¯åŠåˆ†ã«åˆ†å‰²ã—ã¦å‰å¾Œã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨çµåˆã™ã‚‹ â€»1
        sections = merge_min_straight_section(sections)
        # # é€£ç¶šã™ã‚‹åŒä¸€æ–¹å‘ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ãƒãƒ¼ã‚¸(â€»1ã§çµåˆã—ãŸå ´åˆã«åŒä¸€æ–¹å‘ã®ã‚³ãƒ¼ãƒŠãƒ¼ãŒé€£ç¶šã™ã‚‹å ´åˆãŒã‚ã‚‹ãŸã‚)
        sections = merge_continuous_section_section(sections)

        # æ‰±ã„ã‚„ã™ã„å½¢ã«æ•´å½¢
        datas = []
        for section in sections:
            steering_angle_info = section['steering_angle_info']
            # ã‚»ã‚¯ã‚·ãƒ§ãƒ³å†…ã®åº§æ¨™ã‚’1ã¤ã«ã¾ã¨ã‚ã‚‹
            points = []
            for x in steering_angle_info:
                points.append(x['start'])
                points.append(x['center'])
                points.append(x['end'])
            points = list(dict.fromkeys(points))
            # ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®è·é›¢ã‚’è¨ˆç®—
            distance = 0
            for i in range(len(points) - 1):
                distance += geodesic(reversed(points[i]), reversed(points[i+1])).meters
            # ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°è§’åº¦ã®æœ€å¤§å€¤ã€å¹³å‡å€¤ã‚’å–å¾—
            max_steering_angle = max(steering_angle_info, key=lambda x: x['steering_angle'])['steering_angle']
            avg_steering_angle = sum([x['steering_angle'] for x in steering_angle_info]) / len(steering_angle_info)
            datas.append({
                'max_steering_angle': max_steering_angle,
                'avg_steering_angle': avg_steering_angle,
                'elevation_height_and_distance_ratio': elevation_height / distance,
                'section_type': section['type'],
                'steering_direction': steering_angle_info[0]['direction'],
                'points': points,
                'section_info': steering_angle_info,
                'distance': distance,
                'elevation_height': elevation_height,
            })
        return datas
    series = gdf.apply(func, axis=1)
    return series

# 3åº§æ¨™ã‹ã‚‰æ±‚ã‚ãŸã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°å›è»¢é‡ã®æƒ…å ±ã‹ã‚‰ã€ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®å›è»¢æ–¹å‘ãŒé€£ç¶šã™ã‚‹ã‚‚ã®ã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ã—ã¦å·¦ã‚³ãƒ¼ãƒŠãƒ¼ã€å³ã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œã‚‹
def group_continuous_section(target):
    # ã‚¹ãƒ†ã‚¢ãƒªãƒ³ã‚°ã®æ–¹å‘ãŒå¤‰ã‚ã‚‹æ¯ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    old_direction = target[0]['direction']
    sections = []
    # å³å·¦ã‚³ãƒ¼ãƒŠãƒ¼ã®æƒ…å ±
    section_work = [target[0]]
    for i in range(1, len(target)):
        current_segment = target[i]
        angle = current_segment['steering_angle']
        distance = current_segment['distance']
        direction = current_segment['direction']
        if angle < STRAIGHT_ANGLE:
            direction = 'straight'

        if direction == old_direction:
            section_work.append(current_segment)
        else:
            sections.append({'type': old_direction, 'steering_angle_info': section_work})
            section_work = [current_segment]
            old_direction = direction
    # æœ€å¾Œã®æœªå‡¦ç†ã®ã‚»ã‚°ãƒ¡ãƒ³ãƒˆã‚’è¿½åŠ 
    if len(section_work) > 0:
        sections.append({'type': old_direction, 'steering_angle_info': section_work})
    return sections

# çŸ­ã„ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆåŒºé–“ã‚’ã‚³ãƒ¼ãƒŠãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ãƒãƒ¼ã‚¸
def merge_min_straight_section(sections):
    # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆåŒºé–“ãŒ100mæœªæº€ã®å ´åˆã¯åŠåˆ†ã«åˆ†å‰²ã—ã¦å‰å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã¨çµåˆã™ã‚‹
    adjusted_sections = copy.deepcopy(sections)
    is_not_exists_min_straight = True
    while is_not_exists_min_straight:
        # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã‚’æŠ½å‡º
        straights = [x for x in adjusted_sections if x['type'] == 'straight']
        # 100mä»¥ä¸‹ã®ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã‚’æŠ½å‡º
        min_straights = [x for x in straights if sum([y['distance'] for y in x['steering_angle_info']]) < STRAIGHT_DISTANCE]
        if len(min_straights) == 0:
            is_not_exists_min_straight = False
            break
        min_straight_first = min_straights[0]
        # 100mæœªæº€ã®å…ˆé ­indexã‚’å–å¾—
        min_straight_first_index = adjusted_sections.index(min_straight_first)
        steering_angle_info = min_straight_first['steering_angle_info']
        # å‰å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚’å–å¾—
        if min_straight_first_index == 0:
            # å…ˆé ­ã®ã‚³ãƒ¼ãƒŠãƒ¼ã®å‡¦ç†
            next_section = copy.deepcopy(adjusted_sections[min_straight_first_index + 1])
            next_section['steering_angle_info'] = steering_angle_info + next_section['steering_angle_info']
            adjusted_sections[min_straight_first_index + 1] = next_section
        elif min_straight_first_index == len(adjusted_sections) - 1:
            # æœ«å°¾ã®ã‚³ãƒ¼ãƒŠãƒ¼ã®å‡¦ç†
            previous_section = copy.deepcopy(adjusted_sections[min_straight_first_index - 1])
            previous_section['steering_angle_info'] += steering_angle_info
            adjusted_sections[min_straight_first_index - 1] = previous_section
        else:
            if(len(steering_angle_info)) >= 2:
                # å‰å¾Œã®ã‚³ãƒ¼ãƒŠãƒ¼ã«ãƒãƒ¼ã‚¸
                previous_section = copy.deepcopy(adjusted_sections[min_straight_first_index - 1])
                next_section = copy.deepcopy(adjusted_sections[min_straight_first_index + 1])
                # å³å¯†ã«ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®è·é›¢ã®åŠåˆ†ã‚’åˆ†å‰²ã™ã‚‹ã¹ãã ãŒã€ä¸€æ—¦ã¯è¦ç´ æ•°ã‹ã‚‰åˆ†å‰²
                previous_section['steering_angle_info'] += steering_angle_info[:len(steering_angle_info)//2]
                next_section['steering_angle_info'] = steering_angle_info[len(steering_angle_info)//2:] + next_section['steering_angle_info']

                adjusted_sections[min_straight_first_index - 1] = previous_section
                adjusted_sections[min_straight_first_index + 1] = next_section
            else:
                # 1ä»¶ã ã‘ã®å ´åˆã¯ç›´å‰ã®ã‚³ãƒ¼ãƒŠãƒ¼ã«ãƒãƒ¼ã‚¸
                previous_section = copy.deepcopy(adjusted_sections[min_straight_first_index - 1])
                previous_section['steering_angle_info'] += steering_angle_info
                adjusted_sections[min_straight_first_index - 1] = previous_section

        # ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã‚’å‰Šé™¤
        adjusted_sections.remove(min_straight_first)
    return adjusted_sections

# é€£ç¶šã™ã‚‹åŒä¸€æ–¹å‘ã®ã‚³ãƒ¼ãƒŠãƒ¼ã‚’ãƒãƒ¼ã‚¸
# åŒã˜æ–¹å‘ã®ã‚³ãƒ¼ãƒŠãƒ¼ãŒé€£ç¶šã™ã‚‹å ´åˆã¯çµåˆã™ã‚‹ã€‚
def merge_continuous_section_section(road_sections):
    merged_lst = []
    i = 0
    target_sections = road_sections
    while i < len(target_sections):
        current_section = target_sections[i].copy()  # ç¾åœ¨ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ä½¿ç”¨
        # æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒåŒã˜ã‚¿ã‚¤ãƒ—ã‹ç¢ºèª
        while i + 1 < len(target_sections) and target_sections[i]['type'] == target_sections[i + 1]['type']:
            # æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ãŒåŒã˜ã‚¿ã‚¤ãƒ—ã§ã‚ã‚Œã°ã€steering_angle_infoã‚’çµåˆ
            current_section['steering_angle_info'] += target_sections[i + 1]['steering_angle_info']
            i += 1  # æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’ã‚¹ã‚­ãƒƒãƒ—

        # çµåˆã—ãŸã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆã¾ãŸã¯å˜ä¸€ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ï¼‰ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ 
        merged_lst.append(current_section)
        i += 1  # æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã«ç§»å‹•
    return merged_lst
```

ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“æƒ…å ±ã‹ã‚‰ã€é«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã€ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“è·é›¢ã‚’æ±‚ã‚ã¦ãã®å‰²åˆã‚’æ±‚ã‚ã‚‹ã€‚

```python
# å›è»¢é‡7Â°ä»¥ä¸‹ã¯ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã¨ã—ã¦æ‰±ã†
# é«˜é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã®å›è»¢é‡ã®ç¯„å›² 7~45Â°
HEIGHT_CORNER_ANGLE_MIN = 7
HEIGHT_CORNER_ANGLE_MAX = 45
# ä¸­é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã®å›è»¢é‡ã®ç¯„å›² 45Â°~80Â°
MEDIUM_CORNER_ANGLE_MIN = 45
MEDIUM_CORNER_ANGLE_MAX = 80
# ä½é€Ÿã‚³ãƒ¼ãƒŠãƒ¼ã®å›è»¢é‡ã®ç¯„å›² 80Â°~
LOW_CORNER_ANGLE_MIN = 80

# å„ã‚³ãƒ¼ãƒŠãƒ¼ç¨®åˆ¥ã®é–“ã®ã‚¾ãƒ¼ãƒ³å€¤(Â±5åº¦)
# ã‚³ãƒ¼ãƒŠãƒ¼ç¨®åˆ¥ãŒåˆ‡æ›¿ã‚‹é–“ã‚’æ®µéšçš„ã«è©•ä¾¡ã™ã‚‹ãŸã‚ã«ä½¿ç”¨
CORNER_TRANSITION_ZOON = 5

def generate(gdf: GeoDataFrame) -> tuple[Series, Series, Series]:
    def func(x):
        road_section = x['road_section']
        corner_week_distance = 0
        corner_medium_distance = 0
        corner_strong_distance = 0
        corner_none_distance = 0
        # å„ã‚³ãƒ¼ãƒŠãƒ¼ç¨®åˆ¥ã®è·é›¢ã‚’è¨ˆç®—
        for item in road_section:
            angle = item['max_steering_angle']
            distance = item['distance']
            if item['section_type'] == 'straight':
                corner_none_distance += distance
            else:
                if WEEK_CORNER_ANGLE_MIN <= angle < MEDIUM_CORNER_ANGLE_MIN:
                    # å¼±ã‚³ãƒ¼ãƒŠãƒ¼ã®è¨ˆç®—
                    if angle < (WEEK_CORNER_ANGLE_MAX - CORNER_TRANSITION_ZOON):
                        corner_week_distance += distance  # å®Œå…¨ã«ã€Œå¼±ã€ã®é ˜åŸŸ
                    else:
                        # å¢ƒç•Œä»˜è¿‘ã¯é‡ã¿ä»˜ã‘
                        transition_ratio = (WEEK_CORNER_ANGLE_MAX - angle) / CORNER_TRANSITION_ZOON
                        corner_week_distance += distance * transition_ratio
                        corner_medium_distance += distance * (1 - transition_ratio)
                elif MEDIUM_CORNER_ANGLE_MIN <= angle < STRONG_CORNER_ANGLE_MIN:
                    # ä¸­ã‚³ãƒ¼ãƒŠãƒ¼ã®è¨ˆç®—
                    if angle < (MEDIUM_CORNER_ANGLE_MAX - CORNER_TRANSITION_ZOON):
                        corner_medium_distance += distance  # å®Œå…¨ã«ã€Œä¸­ã€ã®é ˜åŸŸ
                    else:
                        # å¢ƒç•Œä»˜è¿‘ã¯é‡ã¿ä»˜ã‘
                        transition_ratio = (MEDIUM_CORNER_ANGLE_MAX - angle) / CORNER_TRANSITION_ZOON
                        corner_medium_distance += distance * transition_ratio
                        corner_strong_distance += distance * (1 - transition_ratio)

                elif STRONG_CORNER_ANGLE_MIN <= angle:
                    # å¼·ã‚³ãƒ¼ãƒŠãƒ¼ã®è¨ˆç®—
                    corner_strong_distance += distance  # å®Œå…¨ã«ã€Œå¼·ã€ã®é ˜åŸŸ
            # ç·è·é›¢ã§æ­£è¦åŒ–
            total_distance = corner_week_distance + corner_medium_distance + corner_strong_distance + corner_none_distance
        score_corner_week = corner_week_distance / total_distance
        score_corner_medium = corner_medium_distance / total_distance
        score_corner_strong = corner_strong_distance / total_distance
        score_corner_none = corner_none_distance / total_distance
        # ãƒãƒ©ãƒ³ã‚¹ã‚’è©•ä¾¡
        values = [score_corner_week, score_corner_medium, score_corner_strong, score_corner_none]
        k = 0.4
        std_dev = np.std(values)
        score = 1 - (std_dev / k)
        return score
    results = gdf.apply(func, axis=1, result_type='expand')
    return results[0]

```

:::
ä¸Šè¨˜ãƒ­ã‚¸ãƒƒã‚¯ã§å„ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã‚’æ±‚ã‚ãŸã‚‚ã®ãŒã“ã¡ã‚‰ã«ãªã‚Šã¾ã™ã€‚

| è¿‘æ‰€ã®é“                                                | è¿‘æ‰€ã®é“ã‚’å„ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã®åŒºé–“ã«åˆ†å‰²ã—ãŸã‚‚ã®                                          |
| ------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| ![è¿‘æ‰€ã®å³ é“](/images/a1f4c292a469b8/image22.png =500x) | ![å¯¾è±¡ã®é“ã‚’å„ã‚³ãƒ¼ãƒŠãƒ¼ã¨ã‚¹ãƒˆãƒ¬ãƒ¼ãƒˆã«åˆ†å‰²ã—ãŸã‚‚ã®ã€‚](/images/a1f4c292a469b8/image23.png =500x) |

ã“ã®4è¦ç´ ã®åŒºé–“è·é›¢ã®å‰²åˆãŒè¿‘ã„é“ãŒå¹³é¢ä¸Šã§è¤‡é›‘æ€§ãŒã‚ã‚Šã‚³ãƒ¼ãƒŠãƒ¼ã¸ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒæ–¹æ³•ãŒå¤šã„é“ã¨ã„ã†äº‹ã«ãªã‚Šã¾ã™ã€‚

# æŠ½å‡ºã•ã‚ŒãŸé“

ã“ã‚Œã¾ã§ã®ãƒ­ã‚¸ãƒƒã‚¯ã§æ±äº¬å‘¨è¾ºã®å³ é“ã‚’æŠ½å‡ºã—ãŸã‚‚ã®ãŒã“ã¡ã‚‰ã§ã™ã€‚
è‰²ãŒæ¿ƒã„æ‰€ãŒã€Œã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã£ã½ã„å³ é“ã€ã®è©•ä¾¡å€¤ãŒé«˜ã„é“ã§ã™ã€‚
ä¸Šä½1~10ã«ã¯ãƒãƒ¼ã‚­ãƒ³ã‚°ã—ã¦ã„ã¾ã™ã€‚
![ç¾¤é¦¬çœŒãŒãŠãŠã„ã§ã™ã­ã€‚ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã®è–åœ°ã‚‚å¤šã„ã®ã§ã„ã„æ„Ÿã˜](/images/a1f4c292a469b8/image24.png)
_ç¾¤é¦¬çœŒãŒãŠãŠã„ã§ã™ã­ã€‚ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã®è–åœ°ã‚‚å¤šã„ã®ã§ã„ã„æ„Ÿã˜_

|                                                                                                                                                                                                                                                                       |                                                                                                                                                                               |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| ![æ¦›åå±±å‘¨è¾ºã€‚å³ä¸Šã®è–„ã„æ‰€ãŒè—¤åŸæ‹“æµ·ã®ãƒ›ãƒ¼ãƒ ã‚¹ãƒãƒƒãƒˆã ãŒã€è¤‡é›‘æ€§ãŒå°‘ãªãå˜èª¿ãªé“ã¨è©•ä¾¡ã•ã‚Œã¦ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³ã—ãªã‹ã£ãŸ](/images/a1f4c292a469b8/image25.png)_æ¦›åå±±å‘¨è¾ºã€‚å³ä¸Šã®è–„ã„æ‰€ãŒè—¤åŸæ‹“æµ·ã®ãƒ›ãƒ¼ãƒ ã‚¹ãƒãƒƒãƒˆã ãŒã€è¤‡é›‘æ€§ãŒå°‘ãªãå˜èª¿ãªé“ã¨è©•ä¾¡ã•ã‚Œã¦ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³ã—ãªã‹ã£ãŸ_ | ![ãƒ¬ãƒƒãƒ‰ã‚µãƒ³ã‚ºã®èµ¤åŸå±±ã¯ä¸Šä½10ã§ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³](/images/a1f4c292a469b8/image26.png)_ãƒ¬ãƒƒãƒ‰ã‚µãƒ³ã‚ºã®èµ¤åŸå±±ã¯ä¸Šä½10ã§ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³_                                                     |
| ![ãƒŠã‚¤ãƒˆã‚­ãƒƒã‚ºã®å¦™ç¾©å±±ã¯ä¸Šä½10ã§ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³](/images/a1f4c292a469b8/image27.png)_ãƒŠã‚¤ãƒˆã‚­ãƒƒã‚ºã®å¦™ç¾©å±±ã¯ä¸Šä½10ã§ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³_                                                                                                                                             | ![ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ–ãƒ«ãƒ¼ã®ç¢“æ°·å³ ã¯å˜èª¿ãªé“ã¨è©•ä¾¡ã•ã‚Œã¦ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³ã—ãªã‹ã£ãŸ](/images/a1f4c292a469b8/image28.png)_ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆãƒ–ãƒ«ãƒ¼ã®ç¢“æ°·å³ ã¯å˜èª¿ãªé“ã¨è©•ä¾¡ã•ã‚Œã¦ãƒ©ãƒ³ã‚¯ã‚¤ãƒ³ã—ãªã‹ã£ãŸ_ |

## ãƒ“ãƒ¥ãƒ¯ãƒ¼ã§ç¢ºèª

ã“ã¡ã‚‰ã‹ã‚‰æ—¥æœ¬å…¨å›½ã®ã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã£ã½ã„é“ã‚’ã”è¦§ã„ãŸã ã‘ã¾ã™ã€‚
https://speedio.homisoftware.net/
ã“ã‚“ãªæ„Ÿã˜ã«å³ ã‚’3Dã§è¡¨ç¤ºã‚‚ã§ãã¾ã™ã€‚
https://www.youtube.com/watch?v=xz4zPHVMLHI

## å®Ÿéš›ã«èµ°ã£ã¦ã¿ãŸ

åœ°å…ƒã®æ„›çŸ¥çœŒã§ã€Œã‚¤ãƒ‹ã‚·ãƒ£ãƒ«Dã£ã½ã„å³ é“ã€ã®ç‰¹å¾´ãŒé«˜ã„é“ã‚’3ã¤é‹è»¢ã—ã¦ã¿ã¾ã—ãŸã€‚

![image.png](/images/a1f4c292a469b8/image30.png)
https://www.youtube.com/watch?v=tqIAvrvP7Dk&list=LL

### æœ¬å®®å±±ã‚¹ã‚«ã‚¤ãƒ©ã‚¤ãƒ³

æ–°åŸãƒ©ãƒªãƒ¼ã§ä½¿ã‚ã‚ŒãŸå®Ÿç¸¾ã®ã‚ã‚‹é“
[https://www.youtube.com/watch?v=gBQaaCD0Rjc](https://www.youtube.com/watch?v=gBQaaCD0Rjc)

### çŸ¢ä½œãƒ€ãƒ 

90å¹´ä»£ã«èµ°ã‚Šã‚¹ãƒãƒƒãƒˆã§æœ‰åæ‰€ã€‚
[http://www.hashiriya.jp/bbs2/test/read.cgi/citokai/1081382495/](http://www.hashiriya.jp/bbs2/test/read.cgi/citokai/1081382495/)

### èŒ¶è‡¼å±±

ã‚µãƒ¼ã‚­ãƒƒãƒˆç¦æ­¢?ã®çœ‹æ¿ãŒçµŒã£ã¦ã„ã‚‹å³ é“ã€‚
![[ã‚¢ï¾‰ï¾šãƒ—ã‚¹ä¹™å¥³ã•ã‚“å£ã‚³](https://bbs.kakaku.com/bbs/-/SortID=24523556/ImageID=3639328/)ã‹ã‚‰å¼•ç”¨ã—ã¾ã—ãŸã€‚](/images/a1f4c292a469b8/image31.png)
_[ã‚¢ï¾‰ï¾šãƒ—ã‚¹ä¹™å¥³ã•ã‚“å£ã‚³](https://bbs.kakaku.com/bbs/-/SortID=24523556/ImageID=3639328/)ã‹ã‚‰å¼•ç”¨ã—ã¾ã—ãŸã€‚_

# ä½œã£ã¦ã¿ã¦æ€ã£ãŸäº‹

è‡ªåˆ†ã®æ„Ÿè¦šã‚’ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§å†ç¾ã™ã‚‹ã®ã¯æ¥½ã—ã„ã§ã™ã­ã€‚ä»•äº‹ã§ã¯çµ¶å¯¾ã«å‘³ã‚ãˆãªã„æ„Ÿè¦šã§ã—ãŸã€‚
ç¾åœ°èª¿æŸ»ã‚’ä½•åº¦ã‚‚ç¹°ã‚Šè¿”ã—ãŸãŠã‹ã’ã§ã‹ãªã‚Šã„ã„æ„Ÿã˜ç²¾åº¦ãŒã§ãŸã®ã¨ã€ãƒ­ã‚¸ãƒƒã‚¯ãŒä»•ä¸ŠãŒã£ã¦ã„ããŸã³ã«ç©ºé–“ã‚’æ”¯é…ã§ãã¦ã„ã‚‹ã‚ˆã†ãªæ°—åˆ†ã«ãªã‚Œã¦æ¥½ã—ã‹ã£ãŸã§ã™ã€‚

# ãŠã‚ã‚Šã«

æœ€å¾Œã¾ã§ãŠèª­ã¿ã„ãŸã ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã—ãŸã€‚
å®Œæˆã—ãŸã‚³ãƒ¼ãƒ‰ã¯ã“ã¡ã‚‰ã§ã”è¦§ã„ãŸã ã‘ã¾ã™ã€‚
https://github.com/ritogk/speedio
